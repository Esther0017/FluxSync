#==================== 全局/主进程配置 ====================

user nginx;                                   # 使用 nginx 用户运行worker进程
worker_processes auto;                        # 自动按 CPU 核心数设置 worker 数

error_log /var/log/nginx/error.log warn;      # 错误日志路径与级别
pid       /var/run/nginx.pid;                 # pid 文件路径


#==================== 事件模型 ====================

events {
    worker_connections 4096;                  # 每个 worker 可同时打开的连接数上限
}

#==================== HTTP 上下文 ====================

http {
    include        /etc/nginx/mime.types;     # 文件类型映射
    default_type   application/octet-stream;  # 默认 MIME 类型

    #----------- 访问日志 -----------#
    log_format    main    '$remote_addr - $remote_user [$time_local] "$request" '
                          '$status $body_bytes_sent "$http_referer" '
                          '"$http_user_agent" "$http_x_forwarded_for" '
                          'rid=$http_x_request_id rt=$request_time uct = $upstream_connect_time urt=$upstream_response_time';
    access_log      /var/log/nginx/access.log   main;   # 使用 main 日志格式记录访问日志

    #----------- 基础性能与超时 -----------#
    sendfile        on;                        # 启用零拷贝发送文件
    tcp_nopush      on;                        # 减少网络包数量 (配合 sendfile)
    tcp_nodelay     on;                        # 及时发送小包 (减少延迟, 对交互请求更友好)
    
    client_max_body_size  50m;                 # 请求体大小上限
    keepalive_timeout     65;                  # keep-alive 超时
    proxy_read_timeout    60s;                 # 反向代理读超时
    proxy_send_timeout    60s;                 # 反向代理写超时
    proxy_connect_timeout 5s;                  # 上游连接超时

    #----------- 压缩 -----------#
    gzip              on;                      # 启用 gzip 压缩
    gzip_min_length   1k;                      # 触发压缩的最小响应体
    gzip_comp_level   5;                       # gzip 压缩级别
    gzip_types        text/plain text/css application/json application/javascript application/xml application/rss+xml application/svg+xml;

    #----------- Docker 内网 DNS -----------#
    resolver 127.0.0.11 valid=30s ipv6=off;    # 使用 Docker 内置 DNS 解析容器名

    #----------- WebSocket 升级头 -----------#
    map $http_upgrade $connection_upgrade {    # 处理 WS 升级时的 Connection 头
        default upgrade;
        ''      close;
    }

    #==================== OpenResty: 共享字典与初始化 ====================

    lua_shared_dict metrics 10m;            # 共享内存字典，用于存储 QPS/计时等指标
    lua_shared_dict req_cache 10m;          # 示例：请求级别缓存/节流可复用

    init_by_lua_block {                     -- Nginx master 进程启动时执行一次
        -- 预加载模块/初始化随机种子等
        math.randomseed(ngx.time() + ngx.worker.pid())
    }

    init_worker_by_lua_block {              -- 每个 worker 启动时执行
        -- 留空占位, 可在此处加载 Lua 模块
    }

    #==================== 上游后端定义 ====================
    upstream frontend_upstream {                       # 前端容器 upstream
        server    frontend:1004;                       # 前端容器地址及端口
        keepalive 64;                                  # 保持与上游的长连接池大小
    };

    upstream backend_upstream {                        # 后端容器 upstream
        server    backend:1003;
        keepalive 64;
    };

    upstream jwt_upstream {                            # JWT 服务 upstream
        server    jwt:1001;
        keepalive 64;
    };

    upstream totp_upstream {                           # TOTP 服务 upstream
        server    totp:1002;
        keepalive 64;
    };

    upstream minio_metrics_upstream {                  # MinIO 性能指标服务 upstream
        server    minio:1005;
        keepalive 64;
    };

    #==================== 服务器块 ====================
    
    server {
        
        listen      1007;                              # 容器内监听 1006
        listen      [::]:1007;                         # IPv6 监听

        server_name _;                                 # 匹配任意主机名

        # 真实客户端 IP 透传
        real_ip_header X-Forwarded-For;                # 信任前置代理传来的 XFF

        # ---------- 通用代理头：保留 Host 与源 IP ----------
        proxy_set_header Host              $host;                      # 透传原始 Host
        proxy_set_header X-Real-IP         $remote_addr;               # 源 IP
        proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for; # 代理链路
        proxy_set_header X-Forwarded-Proto $scheme;                    # http/https

        # ---------- 入口：通用 Lua 处理（请求 ID、计时、黑白名单占位） ----------
        access_by_lua_block {
            ngx.ctx.start_time = ngx.now();
        }

        # ------------------------- MinIO 性能指标 -------------------------
        location /minio/system/ {
            proxy_pass http://minio_metrics_upstream/minio/v2/metrics/cluster/;
        }

        # ------------------------- 前端页面 -> frontend -------------------------
        location / {
            proxy_pass http://frontend_upstream/;

            # WebSocket 升级
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;
        }

        # ------------------------- 后端 API -> backend -------------------------
        location /api/ {
            
            # 在进入 upstream 之前校验 JWT
            access_by_lua_file /usr/local/openresty/nginx/conf/lua/auth/jwt.lua;


            proxy_http_version 1.1;
            proxy_set_header   Upgrade $http_upgrade;
            proxy_set_header   Connection $connection_upgrade;
            proxy_pass http://backend_upstream/;
        }

        # ------------------------- 认证子系统 -> jwt / totp -------------------------
        location /auth/jwt/ {
            proxy_http_version 1.1;
            proxy_set_header   Upgrade $http_upgrade;
            proxy_set_header   Connection $connection_upgrade;
            proxy_pass http://jwt_upstream/;
        }

        location /auth/totp/ {
            proxy_http_version 1.1;
            proxy_set_header   Upgrade $http_upgrade;
            proxy_set_header   Connection $connection_upgrade;
            proxy_pass http://totp_upstream/;
        }

        # ------------------------- 健康检查 -------------------------
        location = /health {
            default_type text/plain;                      # 指定响应类型
            return 200 'ok';                              # 直接返回 200/ok
        }

        # ---------- 在响应头阶段附加处理时长 ----------
        header_filter_by_lua_block {
            local st = ngx.ctx.start_time;
            if st then
                local cost = string.format("%.3f", ngx.now() - st);
                ngx.header["X-Process-Time"] = cost;      -- 本机处理耗时 (秒)
            end
        }

        # ---------- 日志阶段：统计上游耗时、按 URI 聚合 ----------
        log_by_lua_block {
            local dict = ngx.shared.metrics
            if ngx.var.upstream_response_time then
                dict:incr("urt:" .. ngx.var.uri, tonumber(ngx.var.upstream_response_time) or 0, 0)
            end
        }

        # ------------------------- 错误页 -------------------------
        error_page 502 503 504 /50x.html;                  # 上游错误时转到 /50x.html
        location = /50x.html {
            return 500 'upstream error';                   # 返回 500 与简短文本
        }

    }

}